title: GLSL内置变量
date: 2016-5-2 21:11:28
tags: OpenGL GLSL

---
　  GLSL定义了许多内置变量，这些变量一般被用于固定管线的运算，这里主要介绍下各个变量的内容与用法。


<!--more-->

# Vertex shader inputs

```
in int gl_VertexID;
in int gl_InstanceID;
```

## gl_VertexID​
因为Vertex Shader对每个Vertex执行一次，所以gl_VertexID是Vertex Shader当前处理的顶点的索引。

gl_InstanceID​
在执行Instance绘制时，gl_InstanceID是当前实例的索引值，当没有进行Instance绘制时它是默认的0值。

# Vertex shader outputs

```
out gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
};
```

## gl_PerVertex​
Vertex Shader的输出结构，在开启光栅化时会被传输。

## gl_Position
一般是在Vertex Shader经过Model View Proj矩阵变换过的Vertex数据，此时数据位于clip-space， 数据是齐次坐标[x, y, z, w].

## gl_PointSize​
绘制像素点大小，在绘制point primitives时有效。

## gl_ClipDistance​
同于用户自定义的裁剪计算，非负值说明顶点在裁剪面内，负值则被裁剪。
---

# Tessellation Control Shaders input:

```
 in int gl_PatchVerticesIn;
 in int gl_PrimitiveID;
 in int gl_InvocationID;
 ```

## gl_PatchVerticesIn​
每个patch多少个vertices

## gl_PrimitiveID​
当前patch索引值

## gl_InvocationID​
当前patch中vertices的索引值。


Tessellation control shader接受vertex shader的输出作为输入，需要注意的是，由于shader对每个patch执行一次，所以该结构是数组模式。

 ```
in gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
} gl_in[gl_MaxPatchVertices];

 ```
结构内的变量含义在vertex shader那里已经说过了，gl_MaxPatchVertices是patch的顶点数，注意跟gl_PatchVerticesIn的区别。


# Tessellation Control Shaders output:

 ```
patch out float gl_TessLevelOuter[4];
patch out float gl_TessLevelInner[2];
 ```
 这个两个分量主要分别设置了patch的内外细分度

Tessellation Control Shader需要将vertex shader传入的数据继续传输下去，所以有类似的输出的结构体：

 ```
out gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
} gl_out[];
 ```


# Tessellation evaluation shader inputs

 ```
in vec3 gl_TessCoord;
in int gl_PatchVerticesIn;
in int gl_PrimitiveID;
 ```

gl_TessCoord​
细分坐标，利用插值可以产生新的细分顶点

gl_PatchVerticesIn​
与control中类似

gl_PrimitiveID​
当前patch的索引值

patch in float gl_TessLevelOuter[4];
patch in float gl_TessLevelInner[2];

```
in gl_PerVertex
{
 vec4 gl_Position;
 float gl_PointSize;
 float gl_ClipDistance[];
} gl_in[gl_MaxPatchVertices];
```

# Tessellation evaluation shader outputs

```
out gl_PerVertex {
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
};
```

gl_Position​
产生细分数据的clip-space坐标值

gl_PointSize​
像素点大小

gl_ClipDistance​
自定义裁剪

---

# Geometry shader inputs

```
in gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
} gl_in[];
```

```
in int gl_PrimitiveIDIn;
in int gl_InvocationID;  //Requires GLSL 4.0 or ARB_gpu_shader5
```

gl_PrimitiveIDIn​

gl_InvocationID​

# Geometry shader outputs

```
out gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
};
```

out int gl_PrimitiveID;
gl_PrimitiveID = gl_PrimitiveIDIn;


层次渲染通过一下变量实现：

```
out int gl_Layer;
out int gl_ViewportIndex; //Requires GL 4.1 or ARB_viewport_array.
```

# Fragment Shaders input.

```
in vec4 gl_FragCoord;
in bool gl_FrontFacing;
in vec2 gl_PointCoord;
```

## gl_FragCoord​
The location of the fragment in window space. The X, Y and Z components are the window-space position of the fragment. The Z value will be written to the depth buffer if gl_FragDepth​ is not written to by this shader stage. The W component of gl_FragCoord​ is 1/Wclip, where Wclip is the interpolated W component of the clip-space vertex position output to gl_Position​ from the last Vertex Processing stage.
The space of gl_FragCoord​ can be modified by redeclaring gl_FragCoord​ with special input layout qualifiers:
layout(origin_upper_left) in vec4 gl_FragCoord;
This means that the origin for gl_FragCoord​'s window-space will be the upper-left of the screen, rather than the usual lower-left.
layout(pixel_center_integer​) in vec4 gl_FragCoord;
OpenGL window space is defined such that pixel centers are on half-integer boundaries. So the center of the lower-left pixel is (0.5, 0.5). Using pixel_center_integer​​ adjust gl_FragCoord​ such that whole integer values represent pixel centers.
Both of these exist to be compatible with D3D's window space. Unless you need your shaders to have this compatibility, you are advised not to use these features.

## gl_FrontFacing​
This is true if this fragment was generated by the front-face of the primitive; it is false if it was generated by the back-face. Only triangle Primitives have a back face; fragments generated by all other primitives will always have this be set to true​.

## gl_PointCoord​
The location within a point primitive that defines the position of the fragment relative to the side of the point. Points are effectively rasterized as window-space squares of a certain pixel size. Since points are defined by a single vertex, the only way to tell where in that square a particular fragment is is with gl_PointCoord​.
The values of gl_PointCoord​'s coordinates range from [0, 1]. OpenGL uses a upper-left origin for point-coordinates by default, so (0, 0) is the upper-left. However, the origin can be switched to a bottom-left origin by calling glPointParameteri(GL_POINT_SPRITE_COORD_ORIGIN, GL_LOWER_LEFT);​

OpenGL 4.0 and above define additional system-generated input values:

```
in int gl_SampleID;
in vec2 gl_SamplePosition;
in int gl_SampleMaskIn[];
```

## gl_SampleID​
This is an integer identifier for the current sample that this fragment is rasterized for.
Warning: Any use of this variable at all will force this shader to be evaluated per-sample. Since much of the point of multisampling is to avoid that, you should use it only when you must.

##gl_SamplePosition​
This is the location of the current sample for the fragment within the pixel's area, with values on the range [0, 1]. The origin is the bottom-left of the pixel area.
Warning: Any use of this variable at all will force this shader to be evaluated per-sample. Since much of the point of multisampling is to avoid that, you should use it only when you must.

## gl_SampleMaskIn​
When using multisampling, this variable contains a bitfield for the sample mask of the fragment being generated. The array is as long as needed to fill in the number of samples supported by the GL implementation.
Some Fragment shader built-in inputs will take values specified by OpenGL, but these values can be overridden by user control.

in float gl_ClipDistance[];
in int gl_PrimitiveID;

## gl_ClipDistance​
This array contains the interpolated clipping plane half-spaces, as output for vertices from the last Vertex Processing stage.

## gl_PrimitiveID​
This value is the index of the current primitive being rendered by this drawing command. This includes any Tessellation applied to the mesh, so each individual primitive will have a unique index.
However, if a Geometry Shader is active, then the gl_PrimitiveID​ is exactly and only what the GS provided as output. Normally, gl_PrimitiveID​ is guaranteed to be unique, so if two FS invocations have the same primitive ID, they come from the same primitive. But if a GS is active and outputs non-unique values, then different fragment shader invocations for different primitives will get the same value. If the GS did not output a value for gl_PrimitiveID​, then the fragment shader gets an undefined value.

GL 4.3 provides the following additional inputs:
in int gl_Layer;
in int gl_ViewportIndex;

## gl_Layer​
This is either 0 or the layer number for this primitive output by the Geometry Shader.
## gl_ViewportIndex​
This is either 0 or the viewport index for this primitive output by the Geometry Shader.

# Fragment shader outputs

```
out float gl_FragDepth;
```

## gl_FragDepth​

---

# Compute Shaders input.

```
in uvec3 gl_NumWorkGroups;
in uvec3 gl_WorkGroupID;
in uvec3 gl_LocalInvocationID;
in uvec3 gl_GlobalInvocationID;
in uint  gl_LocalInvocationIndex;
```

## gl_NumWorkGroups​
This variable contains the number of work groups passed to the dispatch function.

## gl_WorkGroupID​
This is the current work group for this shader invocation. Each of the XYZ components will be on the half-open range [0, gl_NumWorkGroups.XYZ).

## gl_LocalInvocationID​
This is the current invocation of the shader within the work group. Each of the XYZ components will be on the half-open range [0, gl_WorkGroupSize.XYZ​).

## gl_GlobalInvocationID​
This value uniquely identifies this particular invocation of the compute shader among all invocations of this compute dispatch call. It's a short-hand for the math computation:
gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;

## gl_LocalInvocationIndex​
This is a 1D version of gl_LocalInvocationID​. It identifies this invocation's index within the work group. It is short-hand for this math computation:
```
  gl_LocalInvocationIndex =
          gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y +
          gl_LocalInvocationID.y * gl_WorkGroupSize.x +
          gl_LocalInvocationID.x;
```

# Compute shader other variables
const uvec3 gl_WorkGroupSize;   // GLSL ≥ 4.30

# Shaders  uniforms.

```
struct gl_DepthRangeParameters
{
    float near;
    float far;
    float diff;
};
uniform gl_DepthRangeParameters gl_DepthRange;

uniform int gl_NumSamples; //GLSL 4.20
```
